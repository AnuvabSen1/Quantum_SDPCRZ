# -*- coding: utf-8 -*-
"""SDP (16 - 17).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fMv89XW3UMU9N7GRIJsGCiiT-8K07Pk-
"""

# Commented out IPython magic to ensure Python compatibility.
# %pylab inline

from google.colab import drive
drive.mount('/content/drive')

import os

os.environ['MOSEKLM_LICENSE_FILE'] = '/content/mosek.lic'

# For Google Colab use, commands installing packages
try:
  import google.colab
  IN_COLAB = True
except:
  IN_COLAB = False

# Install PICOS and CVXOPT in Google Colab
if IN_COLAB:
    !pip install -q picos
    !pip install -q mosek

import picos as pic
import numpy as np

print('Solvers supported on this installation of picos:', pic.solvers.all_solvers().keys())
print('Solvers available to picos on this machine :', pic.solvers.available_solvers())

def P23_matrix(da, db1, db2):
    """
    Create the permutation matrix S_{b1,b2} for dimensions m, n, and p
    such that it permutes the tensor product as:
    S_{b1,b2}(|\psi_{a}⟩ ⊗ |\phi_{b_{1}}⟩ ⊗ |\theta_{b_{2}}⟩) = |\psi_{a}⟩ ⊗ (|\theta_{b_{1}}⟩ ⊗ |\phi_{b_{2}}⟩)

    Parameters:
    da (int): Dimension of |\psi_a⟩
    db1 (int): Dimension of |\phi_{b_1}⟩
    db2 (int): Dimension of |\theta_{b_2}⟩

    Returns:
    numpy.ndarray: The permutation matrix
    """
    # Total size of the tensor product space
    total_size = da * db1 * db2

    # Create the permutation matrix
    P = np.zeros((total_size, total_size))

    for a in range(da):
        for b1 in range(db1):
            for b2 in range(db2):
                old_index = a * db1 * db2 + b1 * db2 + b2
                new_index = a * db1 * db2 + b2 * db1 + b1
                P[new_index, old_index] = 1

    return P

# P23 Test
# Define two matrices
phi1 = np.array([[1],
              [2]])
da = 2

phi2 = np.array([[2],
              [3]])
db1 = 2

phi3 = np.array([[4],
              [5]])
db2 = 2

# create permatutation matrix
Sab1b2 = P23_matrix(da, db1, db2)

if np.all(Sab1b2 @ np.kron(np.kron(phi1, phi2), phi3)) == np.all(Sab1b2 @ np.kron(np.kron(phi1, phi3), phi2)):
  print("Permutation matrix is correct")
else:
  print("Permutation matrix is incorrect")

"""# Example 1

Given a bell state $|\phi⟩ = \frac{1}{\sqrt{2}}(|00⟩ + |11⟩)$ check if $\rho_{ab}$ has a $k=1$ extension.
"""

#State to check separability
phiMat = np.array([[1.,0.,0.,1.],
                [0.,0.,0.,0.],
                [0.,0.,0.,0.],
                [1.,0.,0.,1.]])/2

da = 2
db1 = 2
dB = db1
db = dB

#Constants
#----------
pab = pic.Constant("pab", phiMat)

Iab = pic.Constant('Iab', np.eye(da*db))

shpaB = (da*dB,da*dB)
shpab = (da*db, da*db)
shpsys = (da, db)

#Variables
#----------
W = pic.HermitianVariable('W', shpab)
Z0 = pic.HermitianVariable('Z0', shpab)
Z1 = pic.HermitianVariable('Z1', shpaB)

"""The $k=1$ formulation is
$$\max_{W, Z_{0}, Z_{1}}\rho_{ab} \boldsymbol{⋅} W$$
$$\text{subject to } W + Z_{0} + \mathcal{T}_{b}(Z_{1}) = 0$$
$$I_{ab} \boldsymbol{⋅} W = -1$$
$$Z_{0}, Z_{1} \succeq 0$$
"""

prob1P = pic.Problem()

#Constraints
#----------
prob1P.add_constraint(W + Z0 + pic.partial_transpose(Z1, subsystems=(1), dimensions=shpsys) == 0)

prob1P.add_constraint(pic.trace(Iab * W) == -1)

prob1P.add_constraint(Z1 >> 0)

prob1P.add_constraint(Z0 >> 0)

#Objective
#----------
prob1P.set_objective('max',pic.trace(pab*W))

#User readable view of the problem being composed in PICOS'
print(prob1P)

#Solve the problem using cvxopt as a solver
prob1P.solve(verbosity=True,solver='mosek')

print('Status at the end of solving the problem usng mosek:', prob1P.status)

mu1P =  prob1P.value
print('Least mu obtained from solving the SDP using mosek above', mu1P)
print('Since this SDP value is positive, the state is entangled')

"""# Example 2

Check for the existence of PPT symmetric extension with $k=1$ for a two qutrit state
$$p_{ab} = \frac{2}{7}|\psi_{+}⟩⟨\psi_{+}| + \frac{α}{7}\sigma_{+} + \frac{5 -  \alpha}{7}S_{ab}\sigma_{+} + S_{ab}$$
where $|\psi_{+}⟩ = \frac{1}{\sqrt{3}}(|00⟩ + |11⟩ + |22⟩)$, $|\sigma_{+}⟩ = \frac{1}{\sqrt{3}}(|01⟩⟨01| + |12⟩⟨12| + |20⟩⟨20|)$, $S_{ab}$ is the swap operator, and $0 \leq \alpha \leq \frac{5}{2}$
"""

da = 3
db = 3
db1 = db
dB = db1
dab = da * db
daB = da * dB

#Construct input state
idMat = np.eye(da*db1)
psiP = idMat[0] + idMat[4] + idMat[8]
psiP = np.outer(psiP,psiP)
psiP = psiP/np.trace(psiP)

sigPlus = np.outer(idMat[1],idMat[1]) + np.outer(idMat[5],idMat[5]) + np.outer(idMat[6],idMat[6])
sigPlus = sigPlus/np.trace(sigPlus)
sigPlusEx = np.outer(idMat[3],idMat[3]) + np.outer(idMat[7],idMat[7]) + np.outer(idMat[2],idMat[2])
sigPlusEx = sigPlusEx/np.trace(sigPlusEx)

al = 0.75
rhoMat = (2/7)*psiP + (al/7)*sigPlus + ((5-al)/7)*sigPlusEx

#Constants
#----------
pab = pic.Constant("pab", rhoMat)
Iab = pic.Constant('Iab', np.eye(da*db))

shpab = (da*db, da*db)
shpaB = (da*dB,da*dB)
shpsys = (da, db)

#Variables
#----------
W = pic.HermitianVariable('W', shpab)
Z1 = pic.HermitianVariable('Z1', shpaB)
Z0 = pic.HermitianVariable('Z0', shpab)

"""The $k=1$ formulation is
$$\max_{W, Z_{0}, Z_{1}}\rho_{ab} \boldsymbol{⋅} W$$
$$\text{subject to } W + Z_{0} + \mathcal{T}_{b}(Z_{1}) = 0$$
$$I_{ab} \boldsymbol{⋅} W = -1$$
$$Z_{0}, Z_{1} \succeq 0$$
"""

prob2P = pic.Problem()

#Constraints
#----------
prob2P.add_constraint(W + Z0 + pic.partial_transpose(Z1, subsystems=(1), dimensions=shpsys) == 0)

prob2P.add_constraint(pic.trace(Iab * W) == -1)

prob2P.add_constraint(Z1 >> 0)

prob2P.add_constraint(Z0 >> 0)

#Objective
#----------
prob2P.set_objective('max', pic.trace(pab * W))

#User readable view of the problem being composed in PICOS'
print(prob2P)

#Solve the problem using cvxopt as a solver
prob2P.solve(verbosity=True,solver='mosek')

print('Status at the end of solving the problem using mosek:', prob2P.status)
mu2P =  prob2P.value

print('The input state parameter alpha is', al)
print('Least mu obtained from solving the SDP using mosek above is', mu2P)

"""# Example 3

Given a bell state $|\phi⟩ = \frac{1}{\sqrt{2}}(|00⟩ + |11⟩)$ check if $\rho_{ab}$ has a $k=2$ extension.
"""

#State to check separability
phiMat = np.array([[1.,0.,0.,1.],
                [0.,0.,0.,0.],
                [0.,0.,0.,0.],
                [1.,0.,0.,1.]])/2
da = 2
db = 2
db1 = db
db2 = db
dB = db1*db2

#Constants
#----------
pab = pic.Constant("pab", phiMat)


Ia = pic.Constant('Ia', np.eye(da))
Ib = pic.Constant('Ib', np.eye(db))
Iab = pic.Constant('Iab', np.eye(da*db))
IaB = pic.Constant('IaB', np.eye(da*dB))
Ib1b2 = pic.Constant('Ib1b2', np.eye(db1*db2))
Iab1b2 = pic.Constant('Iab1b2', np.eye(da*db1*db2))

Sb1b2 = pic.Constant('Sb1b2', P23_matrix(da, db1, db2)) # swap
prod = pic.Constant('IIb1b2', (Iab1b2 + Sb1b2)/2) # projector

shpa = (da, da)
shpab = (da*db,da*db)
shpb = (db,db)
shpB = (dB,dB)
shpaB = (da*dB, da*dB)
shpsys = (da,db1,db2)

#Variables
#----------
W = pic.HermitianVariable('W', shpab)
Z0 = pic.HermitianVariable('Z0', shpaB)
Z1 = pic.HermitianVariable('Z1', shpaB)
Z2 = pic.HermitianVariable('Z2', shpaB)

"""The $k=2$ formulation is
$$\max_{W, Z_{j}} \rho_{ab} \boldsymbol{\cdot} W$$
$$\text{ subject to }\prod_{b_{1}b_{2}}(W \otimes I_{b_{2}} + Z_{0} + \mathcal{T}_{b_{1}}(Z_{1}) + {T}_{b_{1},b_{2}}(Z_{2}))\prod_{b_{1}b_{2}} = 0$$
$$I_{ab} \boldsymbol{\cdot} W = -1$$
$$Z_{0}, Z_{1}, Z_{2} \succeq 0$$
"""

prob3P = pic.Problem()

#Constraints
#----------
prob3P.add_constraint(prod*(W @ Ib + Z0 + pic.partial_transpose(Z1, subsystems=(1), dimensions=shpsys) + pic.partial_transpose(Z2, subsystems=(1, 2), dimensions=shpsys))*prod == 0)

prob3P.add_constraint(pic.trace(Iab * W) == -1)

prob3P.add_constraint(Z0 >> 0)
prob3P.add_constraint(Z1 >> 0)
prob3P.add_constraint(Z2 >> 0)

#Objective
#----------
prob3P.set_objective('max', pic.trace(pab*W))

#User readable view of the problem being composed in PICOS'
print(prob3P)

#Solve the problem using cvxopt as a solver
prob3P.solve(verbosity=True,solver='mosek')

print('Status at the end of solving the problem:', prob3P.status)

mu3P =  prob3P.value

print('Least mu obtained from solving the SDP above is', mu3P)

"""# Example 4

Check for the existence of PPT symmetric extension with $k=2$ for a two qutrit state
$$p_{ab} = \frac{2}{7}|\psi_{+}⟩⟨\psi_{+}| + \frac{α}{7}\sigma_{+} + \frac{5 -  \alpha}{7}S_{ab}\sigma_{+} + S_{ab}$$
where $|\psi_{+}⟩ = \frac{1}{\sqrt{3}}(|00⟩ + |11⟩ + |22⟩)$, $|\sigma_{+}⟩ = \frac{1}{\sqrt{3}}(|01⟩⟨01| + |12⟩⟨12| + |20⟩⟨20|)$, $S_{ab}$ is the swap operator, and $0 \leq \alpha \leq \frac{5}{2}$
"""

da = 3
db = 3
db1 = db
db2 = db
dB = db1*db2

#Re-construct input state from Example 2
idMat = np.eye(da*db)
psiP = idMat[0] + idMat[4] + idMat[8]
psiP = np.outer(psiP,psiP)
psiP = psiP/np.trace(psiP)

sigPlus = np.outer(idMat[1],idMat[1]) + np.outer(idMat[5],idMat[5]) + np.outer(idMat[6],idMat[6])
sigPlus = sigPlus/np.trace(sigPlus)
sigPlusEx = np.outer(idMat[3],idMat[3]) + np.outer(idMat[7],idMat[7]) + np.outer(idMat[2],idMat[2])
sigPlusEx = sigPlusEx/np.trace(sigPlusEx)

alpha = 1.95
rhoMat = (2/7)*psiP + (al/7)*sigPlus + ((5-al)/7)*sigPlusEx

#Constants
#----------
pab = pic.Constant("pab", rhoMat)
pa = pic.partial_trace(pab, subsystems=(1), dimensions=(db, db))

Ia = pic.Constant('Ia', np.eye(da))
Ib = pic.Constant('Ib', np.eye(db))
Iab = pic.Constant('Iab', np.eye(da*db))
IaB = pic.Constant('IaB', np.eye(da*dB))
Ib1b2 = pic.Constant('Ib1b2', np.eye(db1*db2))
Iab1b2 = pic.Constant('Iab1b2', np.eye(da*db1*db2))

Sb1b2 = pic.Constant('Sb1b2', P23_matrix(da, db1, db2))
prod = pic.Constant('IIb1b2', (Iab1b2 + Sb1b2)/2)

shpab = (da*db, da*db)
shpB = (dB, dB)
shpaB = (da*dB, da*dB)
shpsys = (da,db1,db2)

#Variables
#----------
W = pic.HermitianVariable('W', shpab)
Z0 = pic.HermitianVariable('Z0', shpaB)
Z1 = pic.HermitianVariable('Z1', shpaB)
Z2 = pic.HermitianVariable('Z2', shpaB)

"""The $k=2$ formulation is
$$\max_{W, Z_{j}} \rho_{ab} \boldsymbol{\cdot} W$$
$$\text{ subject to }\prod_{b_{1}b_{2}}(W \otimes I_{b_{2}} + Z_{0} + \mathcal{T}_{b_{1}}(Z_{1}) + {T}_{b_{1},b_{2}}(Z_{2}))\prod_{b_{1}b_{2}} = 0$$
$$I_{ab} \boldsymbol{\cdot} W = -1$$
$$Z_{0}, Z_{1}, Z_{2} \succeq 0$$
"""

prob4P = pic.Problem()

#Constraints
#----------
prob4P.add_constraint(prod*(W @ Ib + Z0 + pic.partial_transpose(Z1, subsystems=(1), dimensions=shpsys) + pic.partial_transpose(Z2, subsystems=(1, 2), dimensions=shpsys))*prod == 0)

prob4P.add_constraint(pic.trace(Iab * W) == -1)

prob4P.add_constraint(Z0 >> 0)
prob4P.add_constraint(Z1 >> 0)
prob4P.add_constraint(Z2 >> 0)

#Objective
#----------
prob4P.set_objective('max', pic.trace(pab*W))

#User readable view of the problem being composed in PICOS'
print(prob4P)

#Solve the problem using cvxopt as a solver
prob4P.solve(verbosity=True,solver='mosek')

print('Status at the end of solving the problem using mosek:', prob4P.status)
mu4P =  prob4P.value

print('The input state parameter alpha is', alpha)
print('Least mu obtained from solving the SDP using mosek above is', mu4P)
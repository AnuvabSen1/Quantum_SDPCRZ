# -*- coding: utf-8 -*-
"""SDP (14 - 15).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1CvK17UK9BMcnY62ytVhWvI--StpeQD7j
"""

# Commented out IPython magic to ensure Python compatibility.
# %pylab inline

from google.colab import drive
drive.mount('/content/drive')

import os

os.environ['MOSEKLM_LICENSE_FILE'] = '/content/mosek.lic'

# For Google Colab use, commands installing packages
try:
  import google.colab
  IN_COLAB = True
except:
  IN_COLAB = False

# Install PICOS and CVXOPT in Google Colab
if IN_COLAB:
    !pip install -q picos
    !pip install -q mosek

import picos as pic
import numpy as np

print('Solvers supported on this installation of picos:', pic.solvers.all_solvers().keys())
print('Solvers available to picos on this machine :', pic.solvers.available_solvers())

def P23_matrix(da, db1, db2):
    """
    Create the permutation matrix S_{b1,b2} for dimensions m, n, and p
    such that it permutes the tensor product as:
    S_{b1,b2}(|\psi_{a}⟩ ⊗ |\phi_{b_{1}}⟩ ⊗ |\theta_{b_{2}}⟩) = |\psi_{a}⟩ ⊗ (|\theta_{b_{1}}⟩ ⊗ |\phi_{b_{2}}⟩)

    Parameters:
    da (int): Dimension of |\psi_a⟩
    db1 (int): Dimension of |\phi_{b_1}⟩
    db2 (int): Dimension of |\theta_{b_2}⟩

    Returns:
    numpy.ndarray: The permutation matrix
    """
    # Total size of the tensor product space
    total_size = da * db1 * db2

    # Create the permutation matrix
    P = np.zeros((total_size, total_size))

    for a in range(da):
        for b1 in range(db1):
            for b2 in range(db2):
                old_index = a * db1 * db2 + b1 * db2 + b2
                new_index = a * db1 * db2 + b2 * db1 + b1
                P[new_index, old_index] = 1

    return P

# P23 Test
# Define two matrices
phi1 = np.array([[1],
              [2]])
da = 2

phi2 = np.array([[2],
              [3]])
db1 = 2

phi3 = np.array([[4],
              [5]])
db2 = 2

# create permatutation matrix
Sab1b2 = P23_matrix(da, db1, db2)

if np.all(Sab1b2 @ np.kron(np.kron(phi1, phi2), phi3)) == np.all(Sab1b2 @ np.kron(np.kron(phi1, phi3), phi2)):
  print("Permutation matrix is correct")
else:
  print("Permutation matrix is incorrect")

"""# Example 3

Given a bell state $|\phi⟩ = \frac{1}{\sqrt{2}}(|00⟩ + |11⟩)$ check if $\rho_{ab}$ has a $k=2$ extension.
"""

#State to check separability
phiMat = np.array([[1.,0.,0.,1.],
                [0.,0.,0.,0.],
                [0.,0.,0.,0.],
                [1.,0.,0.,1.]])/2
da = 2
db = 2
db1 = db
db2 = db
dB = db1*db2
k=2

#Constants
#----------
pab = pic.Constant("pab", phiMat)

Ia = pic.Constant('Ia', np.eye(da))
Ib = pic.Constant('Ib', np.eye(db))
Iab = pic.Constant('Iab', np.eye(da*db))
IB = pic.Constant('IB', np.eye(dB))
IaB = pic.Constant('IaB', np.eye(da*dB))
Iab1b2 = pic.Constant('Iab1b2', np.eye(da*db1*db2))

Sb1b2 = pic.Constant('Sb1b2', P23_matrix(da, db1, db2))

prod = pic.Constant('IIb1b2', (Iab1b2 + Sb1b2)/2)

shpab = (da*db,da*db)
shpb = (db,db)
shpB = (dB,dB)
shpaB = (da*dB, da*dB)
shpsys = (da,db1,db2)

Y_init = Ia

#Variables
#----------
W = pic.HermitianVariable('W', shpab)
Z = pic.HermitianVariable('Z', shpaB)

#Initial Points
#---------
W_init = (-1/(db*pic.trace(Y_init)))*Y_init@Ib
Z_init = (1/((db**(k-1)*pic.trace(Y_init)))*Y_init@IB)

"""The $k=2$ formulation is
$$\max_{W, Z_{j}} \rho_{ab} \boldsymbol{\cdot} W$$
$$\text{ subject to }\prod_{b_{1}b_{2}}(W \otimes I_{b_{2}} + Z)\prod_{b_{1}b_{2}} = 0$$
$$I_{ab} \boldsymbol{\cdot} W = -1$$
$$Z \succeq 0$$

where with $S_{b1,b2}$ defined as
$$S_{b1,b2}(|\psi_{a}⟩ ⊗ |\phi_{b_{1}}⟩ ⊗ |\theta_{b_{2}}⟩) = |\psi_{a}⟩ ⊗ (|\theta_{b_{1}}⟩ \otimes |\phi_{b_{2}}⟩)$$
"""

prob3P = pic.Problem()

#Constraints
#----------
prob3P.add_constraint(prod*((W @ Ib) + Z)*prod == 0)

prob3P.add_constraint(pic.trace(Iab * W) == -1)

prob3P.add_constraint(Z >> 0)

#Objective
#----------
prob3P.set_objective('max', pic.trace(pab*W))

#User readable view of the problem being composed in PICOS'
print(prob3P)

#Solve the problem using cvxopt as a solver
prob3P.solve(verbosity=True,solver='mosek')

print('Status at the end of solving the problem using mosek:', prob3P.status)

mu3P =  prob3P.value

print('Least mu obtained from solving the SDP using mosek above is', mu3P)

"""# Example 4

Check for the existence of PPT symmetric extension with $k=2$ for a two qutrit state
$$p_{ab} = \frac{2}{7}|\psi_{+}⟩⟨\psi_{+}| + \frac{α}{7}\sigma_{+} + \frac{5 -  \alpha}{7}S_{ab}\sigma_{+} + S_{ab}$$
where $|\psi_{+}⟩ = \frac{1}{\sqrt{3}}(|00⟩ + |11⟩ + |22⟩)$, $|\sigma_{+}⟩ = \frac{1}{\sqrt{3}}(|01⟩⟨01| + |12⟩⟨12| + |20⟩⟨20|)$, $S_{ab}$ is the swap operator, and $0 \leq \alpha \leq \frac{5}{2}$
"""

k = 2
da = 3
db = 3
db1 = db
db2 = db
dB = db1*db2

#Re-construct input state from Example 2
idMat = np.eye(da*db)
psiP = idMat[0] + idMat[4] + idMat[8]
psiP = np.outer(psiP,psiP)
psiP = psiP/np.trace(psiP)

sigPlus = np.outer(idMat[1],idMat[1]) + np.outer(idMat[5],idMat[5]) + np.outer(idMat[6],idMat[6])
sigPlus = sigPlus/np.trace(sigPlus)
sigPlusEx = np.outer(idMat[3],idMat[3]) + np.outer(idMat[7],idMat[7]) + np.outer(idMat[2],idMat[2])
sigPlusEx = sigPlusEx/np.trace(sigPlusEx)

alpha = 1.95
rhoMat = (2/7)*psiP + (alpha/7)*sigPlus + ((5-alpha)/7)*sigPlusEx

#Constants
#----------
pab = pic.Constant("pab", rhoMat)
pa = pic.partial_trace(pab, subsystems=(1), dimensions=(db, db))

Ia = pic.Constant('Ia', np.eye(da))
Ib = pic.Constant('Ib', np.eye(db))
IB = pic.Constant('IB', np.eye(dB))
Iab = pic.Constant('Iab', np.eye(da*db))
IaB = pic.Constant('IaB', np.eye(da*dB))
Iab1b2 = pic.Constant('Iab1b2', np.eye(da*db1*db2))

Sb1b2 = pic.Constant('Sb1b2', P23_matrix(da, db1, db2))

prod = pic.Constant('IIb1b2', (Iab1b2 + Sb1b2)/2)


shpab = (da*db, da*db)
shpB = (dB, dB)
shpaB = (da*dB, da*dB)
shpsys = (da,db1,db2)

#Initial Points
#---------
Y_init = Ia
W_init = (-1/(db*pic.trace(Y_init)))*Y_init@Ib
Z_init = (1/((db**(k-1)*pic.trace(Y_init)))*Y_init@IB)

#Variables
#----------
W = pic.HermitianVariable('W', shpab)
Z = pic.HermitianVariable('Z', shpaB)

prob4P = pic.Problem()

#Constraints
#----------
prob4P.add_constraint(prod*((W @ Ib) + Z)*prod == 0)

prob4P.add_constraint(pic.trace(Iab * W) == -1)

prob4P.add_constraint(Z >> 0)

#Objective
#----------
prob4P.set_objective('max', pic.trace(pab*W))

#User readable view of the problem being composed in PICOS'
print(prob4P)

prob4P.solve(verbosity=True,solver="mosek")

print('Status at the end of solving the problem using mosek:', prob4P.status)

mu4P =  prob4P.value

print('Least mu obtained from solving the SDP using mosek above is', mu4P)

print('Status at the end of solving the problem:', prob4P.status)
mu4P =  prob4P.value

print('The input state paramter alpha is', alpha)
print('Least mu obtained from solving the SDP above is', mu4P)